# 1.basic

1. 对于下列代码，请判断输出的结果是什么。

   ``` java
   int i = 1;
   boolean b = !(i++ == 3) ^ (i++ ==2) && (i++==3);
   System.out.println(b);
   System.out.println(i);
   ```

   答：false    3;

   

2. 一个16位无符号二进制数的表示的范围是什么？有符号数呢？它们分别对应Java中什么数据类型？

   答：0～65535；-32768~32767;分别对应char和short

   

3. 标识符相关问题：

   1. 从语法上来说，标识符的命名中什么不能作为开头？

   2. 从语法上来说，可以用中文给标识符命名吗？

   3. <span style=color:red;background:yellow>**按照标识符的约定规范中，应该怎么写标识符命名规范？试着从包名，类名，变量名，方法名等角度具体说明。（重点！！！）**</span>

      答：1.数字不能作为开头；

      ​        2.可以；

      ​        3.类名：使用大驼峰命名法；

      ​           变量和方法名：使用小驼峰命名法；

      ​           包名：在开发公司中以反转公司的域名作为开头，单词字母全部小写，多级包名用“ . ”隔开；

      ​        开头和结尾禁止使用“_”和“$”，命名禁止使用莫名其妙的莫名其妙的字母组合，拼音或拼音组合，更不能直接使用中文。

      

4. Java数据类型相关问题：

   1. 什么是数据类型？（定义）

   2. Java的数据类型分为几类？具体有哪些？（十分基础的问题）

   3. 基本数据类型的数值类型取值范围分别是什么？（该题不要求详细写出答案，请你自己总结和记忆一下。）

      答：1.数据类型， 表示的是一组数据的集合，和基于该数据集合的一组合法操作。

      ​        2.两种，基本数据类型，引用数据类型；

         基本数据类型： 整型：byte，short，int，long。
                                     浮点型：float，double。

      ​                               字符型：char。

      ​                               布尔型：boolean。

         引用数据类型：类，接口，数组

         3. byte：一个字节；short ：两个字节；int ：四个字节；long ：八个字节；

            float：四个字节；double：八个字节；

            char：两个字节；

            boolean ：true和false；

            

5. Java数据类型转换相关问题：

   1. 大的分类上来说，Java数据类型转换有几类？分别是什么？

   2. 这两类数据类型转换，对于基本类型而言是怎么发生的？请从以下三个角度说明类型转换：

      - 数值数据类型的取值范围

      - 是否需要写额外代码

      - 有无数据失真的风险？

        答：1.两类，数据类型转换，强制类型转换。

        ​        2.自动类型转换是从小取值范围到大取值范围，不需要额外代码，浮点数有精度问题，有数据失真风险。

        ​            强制类型转换是从大取值范围到小取值范围，需要额外代码，极易造成数据失真。

        

6. Java中的运算符很多，运算符的优先级也不好全部都记忆下来，实际开发中应该怎么做？

   答：避免同时进行多个运算符的运算，分步骤进行。

   

7. 在使用Scanner做键盘录入时，为什么不能混用next系列方法和nextLine方法？

   答：next系列方法使用换行符结束扫描后，当nextLine()方法碰到回车就结束扫描，所以该方法会直接接收到一个空字符串。



# 2.method

1. 方法的实参和形参的区别是什么?

   答：实参：调用方法时传入的具体数据参数称之为实际参数

   ​        形参：形参完全可以理解成一个占位符，它的作用只是告诉方法的调用者，该传入什么类型的参数

2. 方法重载发生的条件是什么?形参的名字不同能否构成方法的重载?

   答：重载条件：语法要求：

   ​        一个类中的多个方法，可以具有相同的方法名，但是它们的形参列表必须不同。

   ​        形参列表不同意味着：

   ​        形参数量不同
   ​        形参数量相同时，形参的数据类型不同
   ​        形参数量和数据类型都相同时，形参的数据类型的顺序不同

3. 方法可以没有返回值吗？可以没有返回值类型吗?

   答：可以；不可以

4. 什么是全限定类名？它的作用是什么？

   答：全限定类名：我们把包名 + 类名这种可以唯一确定一个类的类名书写形式，称之为 全限定类名。

   ​        作用：它的作用就是唯一的、准确的定位一个类。

5. 方法的返回值类型或者形参类型是double，意味着可以使用什么类型的返回值或实参？（自动类型转换）

   答：byte，short，int，long，float，double，char



# 3.array

1. 数组的声明方式有几种？分别是什么？应该使用哪种方式？

2. 答：两种

   ```
   1.数据类型[] 数组名;
   ```

   ```
   2.数据类型 数组名[];
   ```

   ​        用第一种

   

3. 数组的初始化方式有几种？分别是什么？它们分别在什么场景中使用？

   答：两种。静态初始化，动态初始化。

   静态：已经明确需要存储的数据。

   ​       1.数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3...};

   ​       2.数据类型[] 数组名 = {元素1,元素2,元素3...};

   动态：只知道存储数据的数量

   ​          数据类型[] 数组名 = new 数据类型[数组长度];

   

4. 数组创建后，还能修改它的长度吗？可以修改元素的取值吗？

   答：不能；可以。

   

5. 动态初始化数组并没有指出数组中元素的具体取值，这时数组可用吗？为什么？请指出各种数据类型数组对象中的元素默认值。

   答：1.可用，JVM会赋默认值

   ​        2.基本数据类型

   - 整形（byte、short、int、long）默认值为0

   - 浮点类型（float、double）默认值为0.0

   - 字符类型（char）默认值是'\u0000' 表示编码值为0的字符，一个绝对空字符。

   - 布尔类型（boolean）默认值是false

     ​    引用数据类型：null

   - null既不是对象也不是任何一种数据类型，它仅是一个特殊的值

   - 任何引用数据类型的引用都可以指向null，指向null并不意味着没有初始化，可以认为引用指向了虚无，反正没有指向任何一个对象。

   - 对象才是引用数据类型的实质，没有指向对象的引用实际上没有任何意义，指向null的引用是无法正常使用的

   - 基本数据类型不能等于null

     

6. （数组）对象中的元素具有默认值，那么引用具有默认值吗？

   答：有，为null；

   

7. 说出你对引用数据类型的理解。（可以结合JVM内存模型）

   引用数据类型是Java的两大数据类型之一，通过数组初始化的内存分配过程来一窥引用数据类型的特点。

   引用数据类型的创建分为两部分：

   1. 首先是在栈上分配一片空间给引用数据类型的引用，简称`引用`，它是一个局部变量，直接存储在栈帧中。
   2. 在堆上开辟一片空间，用于存放引用数据类型的实际信息，称之为`对象`或者`实例`

   ------

   虽然有两个部分，但**对象才是引用数据类型的实质**，栈上的引用通过存储对象的地址，指向了堆上对象，这样就可以通过引用间接访问堆上的对象。

   **总结来说就是：对象是实质，但我们不能直接访问堆上的对象，而是通过栈上的引用间接访问。**

   

8. JVM内存模型中，栈和堆的作用是什么？（简要说明即可）

   答：栈：主要是用来执行程序，在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配

   ​        堆：用于存放由new创建的对象和数组



# 4.array2

1. 数组操作中会碰到哪些异常？是什么原因导致的?

   答：1.数组下标越界异常（ArrayIndexOutOfBoundsException），用来描述访问了某个数组的一个不存在（不合法）的下标时的问题。

   ​        2.空指针异常（NullPointerExceptionE），用来描述通过一个指向null的引用访问对象时的问题。当引用数据类型的引用指向了null（空常量）时，表示引用是没有指向任何对象，这时如果还想通过引用操作堆上对象，就会空指针异常（因为没有任何对象可供操作）

   

2. 数组遍历方式中，普通for循环和增强for循环有什么不同？它们的使用场景是什么样的？

   答：区别：

   1. 增强for的语法更简洁，并且遍历效率也会更高一点。结合快捷键（iter）使用，做遍历时无疑会更方便。

   2. 增强for循环中没有使用数组下标，而是直接遍历元素。当你想要在循环中使用数组下标时，就无法使用增强for了。

   3. **增强for也叫迭代器（iterator），**它仅仅作为一个遍历数组/集合的工具而存在， **在增强for当中是不能修改任何元素的取值的。**

      需要使用数组下标使用普通for循环，不需要使用数组下标使用增强for循环。

      

3. 什么是值传递？什么是引用传递？Java方法的传值方式是什么？这意味着什么？（方法能够对传入的实参数值做什么操作？）

   答：值传递：指的是调用方法时，传入的是实参的拷贝而不是实参本身。

   ​        引用传递：指的是调用方法时，传入的是实参变量的地址，也就是实参本身。

   ​       Java的传值方式：值传递

   ​       Java方法对方法参数能做什么？

   1. 不能修改基本数据类型的实参的值，也不能修改引用数据类型实参引用的取值

      - **一个方法不能修改其它方法中局部变量的取值。**
      - **一旦违反上述原则，那么局部变量就不"局部"了。**

   2. 可以改变引用数据类型中对象里的数据（称之为**改变对象的状态**，改变对象的属性值）

      

4. 可变参数的本质是什么？在方法体中怎么使用可变参数？

   答：数组

   1. 可变参数用于形参列表中，并且**只能出现在形参列表的最后。**

   2. 语法：

      `[修饰符列表] 返回值类型 方法名 (形式参数列表,数据类型... 变量名){`

       `//方法体`

      `}`

   3. 可变参数的三个点位于数据类型和变量名之间，前后有无空格都可以。最好是前无空格，后有空格。

   4. 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数

      

5. 使用递归要注意什么？

   答：

   1. 合法的递归，除了要有递归体语句外，还要有递归出口。无限制的递归下去，会引发栈溢出错误（StackOverflowError）

   2. 即便是有出口的递归，递归的深度也不能超过栈空间的大小，否则仍然会报错。

      

6. 递归的优缺点是什么？

   优点：

   1. 递归的代码会非常简洁，这是最直观的。
   2. 人在解决问题的时候，都会下意识的分解问题。递归的思想很符合人的思维，用递归求解一个问题的思路很容易被人理解。
   3. 接第二条，一旦能够找打分解问题的思路，递归会非常好用。

   缺点：

   1. 不用递归时，往往一个方法就能解决问题。而递归会调用多个方法，占用大量栈内存，且明显存在重复计算，效率低。也就是说，**使用递归求解一个问题，时间和空间复杂度都不占优势，既占用空间效率还低。**
   2. 栈溢出错误警告！递归很危险，一旦栈溢出是严重错误！



# 5.oop

1. 二维数组的本质是什么？内存中存在二维数组的特殊内存结构吗？

   答：指一个一维数组中的元素是一维数组；不存在



2. 什么是类？什么是对象？（根据自己理解写一下即可）

   **对象**：Java 是面向对象的编程语言，独立的个体就是**对象（Object）**，对象就是面向对象程序设计的核心。

   对象之间相互协作，共同实现程序的功能。

   现实中存在的个体，Ta们具有特定的属性和特定的行为，程序世界中的**对象**也类似，具有以下特点：

   1. 对象独立存在，具有属性和行为。
      1. **属性**：个体的状态信息（数据）
      2. **行为**：个体能够做什么（操作）
   2. 对象的状态（属性）可以改变。
   3. 对象具有类别之分，不同类别的对象是不同的。

   **类**：在Java中把创建对象的"模板"，称之为**类（class）**。

   也就是说，到目前为止，我们终于可以给我们之前天天用的类（class）下一个明确的定义了：

   **创建对象的模板就是类！类就是创建对象的模板！**

   既然类是模板，那么：

   类就抽取了同类别的所有对象**属性和行为**上的**共性**，一个类可以描述千千万万个对象。



3. 创建对象和类加载谁先谁后？某个类的类加载在程序某一次运行过程中，有几次？

   答：先进行类加载，再创建对象；一次；



4. 包装类有哪些？简要描述一下。

   | 基本数据类型 |  包装类   |
   | ------------ | :-------: |
   | char         | Character |
   | short        |   Short   |
   | int          |  Integer  |
   | byte         |   Byte    |
   | long         |   Long    |
   | float        |   Float   |
   | double       |  Double   |
   | boolean      |  Boolean  |



5. 对于下述代码：

   ``` java
   public class Demo{
     public static void main(String[] args){
       Demo d = new Demo();
     }
   }
   ```

   main方法中创建Demo对象，会触发Demo类的类加载吗？

   我们把一定会触发类加载的场景，称之为类加载的时机。总结目前为止，类加载的时机。

   答：会的 只有在类加载后 才会创建对象。



6. **创建对象过程中，成员变量的赋值有很多手段，总结到目前为止成员变量的赋值方式。并谈一谈它们执行的先后顺序。**

   默认赋值-->显式赋值-->构造器赋值



# 6.static

1. static修饰的成员属于谁？如何访问？非static修饰的成员属于谁？如何访问？

   答：1.属于类，类名点；

   ​        2.属于创建出的对象，对象点；

2. 静态成员变量在类全局唯一吗？成员变量在类全局唯一吗？

   唯一，不唯一。

3. 总结目前为止，成员变量和静态成员变量的赋值以及顺序。（分别指的是创建对象时期，和类加载时期）

   答;成员变量：默认值-->显式赋值

   ​     静态成员变量:默认初始化-->显式赋值-->构造器赋值



# 7.block

1. 简述一下构造代码块和静态代码块的作用和执行时机。

   答：1.构造代码块：随着构造器的执行而执行，用于在创建对象过程当中，给成员变量赋值！！

   ​       2.静态代码块：随着类加载的过程而执行，静态代码块可以看成是一个在类加载过程中，会自动调用的静态方法！用于给静态成员变量赋值！

2. 总结目前为止，成员变量和静态成员变量的赋值以及顺序。

   成员变量：默认初始化->(构造代码块和显式赋值按书写顺序执行)->构造器

   静态成员变量-：默认初始化->（显式赋值和静态代码块按书写顺序执行）

3. 描述一下各种访问权限修饰符的访问级别。（排除protected，因为没讲）

   |                    | private | default | protected | public |
   | ------------------ | ------- | ------- | --------- | ------ |
   | 1.在同一包的同一类 | √       | √       |           | √      |
   | 2.同一包的不同类   |         | √       |           | √      |
   | 3.不同包的子类     |         |         |           | √      |
   | 4.不通包的非子类   |         |         |           | √      |

4. Getter/Setter方法的好处是什么？定义类时需要无脑加上Getter/Setter方法吗？

   ​     好处：Getter/Setter方法使成员变量的读、写分离了，从原先的不可控变成了可控。在实际开发中，一个类的多数成员变量都是私有的，有必要时提供方法访问，无必要的则无需提供。

   ​     **真正的封装指的是：经过深思熟虑，依靠精巧的设计，暴露给外界"功能完善但最少"的接口，并使用具体的内部实现完全对外透明。**（透明指的是，使用者能够顺利得到自己想要的功能，而完全感受不到内部的实现细节。但是如果设计者为了隐藏而隐藏，将本不该私有的成员私有化了，以至于使用者没办法正常完成功能，只能通过奇怪的方式去完成**（比如完全不必要的Getter/Setter方法）**，不仅不方便，还有可能引发错误。）



# 8.extends

1. 继承使用什么关键字？继承中的两个类是什么关系？

   extends

   从属关系：继承中的父子类具有 **"is-a"** 关系。即子类 **"is-a"** 父类。子类可以近似地看成是一个父类，子类可以当作父类来使用。

   

2. Java中一个类能否**直接**继承两个类？Java中一个类就只能有一个父类吗？

   不能；不是。

   

3. 如果一个类没有明确继承某个类，那么它就没有父类吗？

   不是，Object

   

4. A继承B，C也继承B，那么A和C**（血缘上是兄弟姐妹关系）**这两个类**从继承上**来说有什么关系？

   没有关系

   

5. 引用数据类型能否发生数据类型转换？如果能发生，前提是什么？

   能；从属关系

   

6. 从继承方向的角度上，描述引用数据类型的自动类型转换和强制类型转换，并指出它们的特殊叫法。

   自动类型转换：

   引用数据类型的自动类型转换指的是：**无需程序员写额外代码，编译器自动完成类型转换。**

   1. 条件：**把子类的引用转换成父类的引用，由于子类"is-a"父类，所以这个过程不需要写额外代码，自动完成转换。**
   2. 从继承的角度上来说，子类引用转换成父类引用，在继承方向上是从下往上的。 **所以引用数据类型的自动类型转换也称之为"向上转型"。**

   强制类型转换：引用数据类型的强制类型转换，自然指的是需要程序员写额外代码强制完成的类型转换。

   1. 条件：**把父类的引用转换成子类的引用时，显然父类不能随便作为子类使用。这个过程需要写额外代码完成，是强制类型转换。**

   2. 强转额外代码的语法:

      ```
      子类的对象名 = (子类的类名)父类引用
      ```

   3. 从继承的角度上来说，父类引用转换成子类引用，在继承方向上是从上往下的。 **所以引用数据类型的自动类型转换也称之为"向下转型"。**

      

7. 描述protected访问权限级别（从同包，不同包的角度回答）

   不同包下的子类

   

8. 私有成员可以被子类继承吗？

   1. 首先，直接访问是访问不到的。 **但实际上子类会继承父类的私有成员，之所以不能访问，是因为没有访问权限。**

      

9. 构造器能够被子类继承吗？

   不能，不是成员

   

10. 静态成员可以被子类继承吗？

    可以使用，不能继承

    

11. 子类对象隐式初始化的条件是什么？

    隐式对象初始化的必要条件：

    1. **父类中有默认的构造方法**
    2. 子类的构造器中没有显式使用super调用父类的构造方法，也没有用this去调用自己的构造方法。

    达成上述两个条件，则JVM在初始化子类对象时进行隐式初始化，永远先执行父类的构造方法，顺序为：

    1. 最上层的父类（Object）

    2. 其他父类（继承链中越处于上流越先执行）

    3. 所有父类的构造方法都执行完毕，开始执行子类构造方法

       

12. 描述一下**对象名点访问成员变量**的访问机制

    - 访问范围
    - 访问结果

    从上述两个角度来说明这个机制。

    访问范围：对象名点成员变量，它的访问范围是由 **引用的数据类型** 来决定的。

    1. 如果引用是父类类型，那么它的访问范围只有父类（和父类的父类）。
    2. 如果引用是子类类型，那么它的访问范围是子类 + 父类（父类如果还有父类也算上）。

    访问结果：对象名点成员变量，访问的结果也是由 **引用的数据类型** 来决定的。

    1. 如果引用是父类类型，那么它的访问结果一定也是父类中的结果。
    2. 如果引用是子类类型，那么它的访问结果一定也是子类中的结果。



# 9.final

1. final修饰类时表示什么？final修饰方法时表示什么？
2. final修饰变量表示什么？分别从两个角度回答：
   - 修饰基本数据类型变量和引用数据类型
   - 修饰局部变量，成员变量，静态成员变量
3. 测试一下访问类的全局常量，哪些情况不会触发该类的静态代码块执行？**（测试不同种类的全局常量）**

学生答案:

1.final修饰类时：表示最后的类，最终的类。即表示这个类不能被继承。

  final修饰方法：表示最后的方法，最终的方法，表示该方法无法被重写 **（但是仍然可以被继承）**。

2.final修饰变量：表示最后的变量，最终的变量，即表示常量。

  final修饰变量时，可以修饰基本数据类型变量，也可以修饰引用数据类型。

1. 1. 修饰基本数据类型时，很容易理解，值不变。
   2. **修饰引用数据类型时，修饰的是引用而不是对象，表示引用中存储的地址成为一个常量，不可更改。**这意味着引用指向的对象不可更改了，不能再指向一个新的对象了。**但对象中成员变量的取值仍是可以修改的。（对象的状态仍可变）**

  局部变量：方法中的局部位置有两个：

1. 方法体：
   - 方法体中用final修饰局部变量，表示该变量一旦声明并初始化赋值，就不可再修改它的取值了。
   - 语法上，直接使用final修饰即可。
2. 方法的形参列表中：
   - **形参用final修饰后，不是表示该方法只能传入常量，而是实参一旦传入后就无法在方法体中修改了。**
   - 语法上，直接使用final修饰即可。 

   成员变量：final修饰成员变量表示该成员变量变成了一个常量，它在内存中的位置，生命周期，使用方式等都不会改变。

​         **成员常量的赋值，有且必须有一次。**

  静态成员变量：final修饰静态成员变量表示一个静态的"常量"，在**类的全局仅有一份**，所以final修饰静态成员变量，也称之为**"全局常量"**。它是一个真正意义上的常量，不会因为创建对象而更改，实际开发中的常量多使用它。



# 10.interface

## 10.1 interface1

1. 指出多态的发生条件，并说明不能发生多态的场景。
2. 当存在父类引用指向多个子类对象时：
   1. 分别访问父子类的同名成员变量，存在多态现象吗？
   2. 分别调用父子类的同名成员方法，存在多态现象吗？
3. 引用数据类型的强制类型转换（向下转型）语句，能够通过编译的条件是什么？
4. 引用数据类型的强制类型转换（向下转型）语句，能够运行成功的条件是什么？
5. 向下转型如此危险，需要instanceof关键字判断后再进行，请描述instanceof的使用语法。

学生答案:

答：

一丶

1.多态发生的条件：

1. 必须存在继承，多态一定发生在父子类之间。
2. 必须存在方法重写，不同的子类需要重写父类中的同名方法。
3. 必须存在父类引用指向子类对象

2.不能发生多态的场景：

1. 不能继承的类，即final修饰的类。一个final修饰的类都没有子类，多态肯定和它无缘。
2. 不能重写的方法，不能重写也没有多态。不能重写的方法有：
   1. final修饰的方法，final限制了重写
   2. static方法，不参与继承和重写。
   3. private方法，没有权限重写。
   4. 构造方法，不能继承。

二丶

不存在，存在。

三丶

通过编译的条件：**必须将父类引用转换成它的子类引用，如果不是转换成它的子类引用，会编译报错。**

四丶

成功运行的条件： **父类引用指向的真实对象的类型，就是要强转成的子类类型的对象或者子类对象。**

五丶

```
引用名 instanceof 类名  
```

上述语法返回一个boolean类型值：

1. **true表示该引用指向的对象，是后面类名的一个对象或者子类对象。**
2. 反之，false则表示不是。
3. **当引用指向null时，使用该语法，结果会直接返回false。*



## 10.2 interface2

1. 请描述抽象类的成员特点（变量、方法、构造器、代码块等）

   **注：实际上你完全可以用一句话来回答这道题。**

2. 请描述接口的成员特点（变量、方法、构造器、代码块等）

3. 总结接口、抽象类、普通类的继承和实现（谁可以继承谁，谁能够实现谁，具体有什么特点等）

学生答案:

一丶

   跟普通类一样。

二丶

   成员变量：默认都是public static final修饰的公共的全局常量。

   方法：抽象方法，默认方法，静态方法。

   构造器，代码块：接口没有构造方法，没有构造代码块，也没有静态代码块

三丶

   类和类继承: 单继承

   接口和接口继承: 接口可以继承接口,并且接口的继承是多继承

   实现: 只能类实现接口,接口不能实现类



# 11.inner

1. 总结成员内部类和静态内部类的成员特点和访问特点。（尽量简洁的用一句话描述）
2. 什么是功能接口？
   1. 功能接口中只能有一个方法吗？
   2. 功能接口中只能有一个抽象方法吗？

学生答案:

一丶内部成员类：成员特点：只允许不触发类加载的。

​            访问特点：成员内部类与外部类之间受访问权限限制；

​                   成员内部类与外围类之间不受访问权限的限制。

   静态内部类：成员特点：与普通成员一样  ；

​            访问特点：静态内部类和外部类之间，需创建对象，受访问权限控制；

​                   静态内部类与外围类之间，需创建对象，不受访问权限限制。

二丶

   功能接口：必须有且仅有一个必须要实现的抽象方法

​      不是，不是



# 12.lambda

1. Lambda表达式语法创建的是什么？是一个类吗？是对象吗？
2. 对于语法() -> {}，描述一下() 和 {}的简化。
3. 描述一下Lambda表达式的方法引用。尤其说明一下什么样的方法可以作为Lambda表达式的实现指向。

学生答案:

一丶一个对象，并且是接口的子类对象。

二丶小括号：如果形参列表中的形参只有一个，那么`()`小括号，也是可以省略的；

   大括号：

1. 如果方法重写的方法体只有一条语句的话，那么可以省略大括号。（类似于if/for省略大括号）
2. 特殊的，如果只有一条语句且这条语句是返回值语句，那么大括号和return可以一起省略。

三丶

1. 返回值类型必须一致。
2. 形参列表中的数量，类型，位置必须都对应上，形参名字无所谓。
3. 方法的名字无所谓。



# 13.object

1. equals方法和hashCode方法的重写需要注意什么事项？
2. 给一个类的对象做克隆操作的步骤是什么？
3. 什么是深度克隆？怎么做深度克隆？
4. 包装类型的自动拆装箱如何实现？
5. 包装类型比较取值为什么不能用"=="呢？

学生答案:

一丶1.equals方法重写注意事项

1. 在实现排他性时，实际上有两种选择：

   1. **使用getClass方法比较**。 **这个比较是比较苛刻的，只有在完全是同一个类型时才会返回true**

   2. **使用instanceof比较**。

      ```
      引用 instanceof 类名
      ```

      表示判断引用所指向的对象的具体类型，是否是后面类名的对象或者子类对象，如果是就返回true，如果不是就返回false。

      这个比较的条件就比较宽松了，可以允许传入子类对象。（当子类对象的父类成员和父类对象相同时,equals方法仍然返回true）

2. equals方法也是可以用快捷键自动生成的，使用快捷键`alt + insert`。而且可以选择在实现`排它性`时的方式。

3. 浮点数比较特殊，它具有规格化和非规格化的区别，还有非数(NaN)，无穷大，无穷小很多特殊的概念，正常情况下，如果仅仅比较数值，用`==`比较相等是够用的。但为了避免因浮点数特殊值，而出现的错误。实际开发中，从严谨角度出发，浮点数的比较仍然建议使用，对应包装类型的`compare`方法去比较浮点数的大小：

   1. Float.compare(float a,float b)
   2. Double.compare(double a,doublet b)

   这两个方法在,a < b时返回-1(负数)，在a>b时，返回1(正数)，只有在两个浮点数相等时，才会返回0

4. 如果类中有引用数据类型成员变量，需要去调用它们的equals方法完成比较。这就意味着还需要重写这个类的equals方法。

5. 财务金额上的运算是不推荐使用浮点数的，会出现精度问题。推荐使用`BigDecimal`这个类完成运算。

   2.hashCode方法的重写

1. **一旦重写hashCode方法后，默认的toString方法就不会再打印地址值了。这是因为toString方法，默认调用的是本地方法的hashCode方法获取地址值，重写后不再是地址值了。**
2. 如果类中有引用数据类型成员变量，那么就继续调用它的hashCode方法，也就需要重写它的hashCode方法。

**hashCode方法和equals方法要重写必须一起重写，而且重写的依据必须是一样的，这样才能保证两个方法的结果具有一致性。比如一个Student类，如果equals方法依据其中的成员变量age和name重写的，那么hashCode方法也必须要依赖于这两个成员变量重写！！**

 

二丶

1. 第一步，首先就要解决的就是访问权限的问题。在默认的情况下，只能在子类中自己"克隆"自己，这种需求还是很少见的。所以为了能够在类的外部调用该类的clone方法，**就需要在该类中重写clone方法的访问权限。**

2. 第二步，可以选择重写方法的返回值类型，从Object改为自身类型。很显然Object当中的克隆方法的默认实现，只会得到一个一模一样且独立的对象，肯定不可能改变对象的类型。**这一步不是必须的，但推荐做一下。**

   注：方法体在多数情况下，我们使用Object默认实现就够了，不要重写它。

3. 第三步，一个类想要做克隆操作，必须要先实现一个接口`java.lang.Cloneable`，表示该类允许进行克隆。如果一个类没有实现接口`java.lang.Cloneable`，又要强行进行克隆操作，就会抛出异常`CloneNotSupportedException`。 **接口`java.lang.Cloneable`是一个类能够调用clone方法的标志。**

三丶什么是深度克隆

  **如果能够让引用数据类型成员变量之间也能相互独立，克隆后获取真正独立的两个对象。我们称之为"深度克隆"。**

   怎么做深度克隆

1. 将引用指向的对象，也克隆一份。
2. 然后让克隆后的引用指向它。

四丶包装类型的自动拆装箱如何实现

  装箱依赖于：包装类型类名.valueOf(对应基本数据类型)；

  拆箱依赖于：包装类型对象名.基本数据类型名字Value()；

五丶包装类是一个类，它是一个引用数据类型



